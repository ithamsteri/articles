# Используем try!

Я начал усердно заниматься изучением Rust'а пару недель назад. Будучи
программистом на С++, этот язык мне показался знакомым и чувствовал себя как в
своей тарелке. Радовало управление памятью и абстракции без накладных расходов.

Я был сильно удивлён, когда стал искать исключения в Rust, что их там нет.
Вместо них были конструкции вида:

```rust
fn foo_maker() -> Result<Foo, io::Error> { ...}
```

Мне был знаком такой функциональный стиль, когда-то я игрался с языком Haskell,
но всё равно не был уверен как использовать это. На первый взгляд, возвращаемое
значение функции это `Result`, которое может содержать `Foo` или `io:Error`. Это
не кажется таким сложным. Результат мы можем проверить с помощью конструкции
`match`:

```rust
let result = foo_maker();
match result {
    Ok(foo) -> foo,
    Err(err) -> println!("Error: {:?}", err)    // Сообщим пользователю о ошибке
}
```

Превосходно! Вам может показаться, что такая проверка на ошибки является милой.
Но это так кажется на первый взгляд. В реальном коде как правило приходится
делать несколько чтений подряд:

```rust
let num_chans = read_u16_le(&mut f);
let samples_per_sec = read_u32_le(&mut f);
let avg_bytes_per_sec = read_u32_le(&mut f);
let block_align = read_u16_le(&mut f);
let bits_per_sample = read_u16_le(&mut f);
```

Каждое чтение данных из файла может вернуть нам ошибку. Возможно умирает жесткий
диск, или кто-то случайно обрезал конец файла. Поэтому каждая функция возвращает
`Result`, который мы должны проверять с помощью конструкции `match` и извлекать
оттуда значение. Вот это уже не кажется милым.

Если покопаться на просторах интернета, то можно найти способ которым можно
обойти проверку результата с помощью метода `unwrap()`. Вызов `unwrap()`
разворачивает `Result` и возвращает нам значение, предполагая что `Result`
является `Ok`. А что если является `Err`? Тогда приложение "впадает в панику".

```rust
let num_chans = read_u16_le(&mut f).unwrap();
let samples_per_sec = read_u32_le(&mut f).unwrap();
let avg_bytes_per_sec = read_u32_le(&mut f).unwrap();
let block_align = read_u16_le(&mut f).unwrap();
let bits_per_sample = read_u16_le(&mut f).unwrap();
```

Если вы увидели такой код и по вашей спине побежали мурашки, то это значит
знаете почему так код плох. А теперь поговорим о том как сделать этот код лучше.

## На помощь к нам спешит try!

А теперь посмотрим на пример использования макроса `try!` в Rust. Когда я его
увидел, то подумал, что может это наше спасение:

```rust
use std::io;
use std::fs::File;

fn main() {
    let mut f = try!(File::open("foo.txt"));
}
```

... и программа вывалила это на экран:

```
<std macros>:5:8: 6:42 error: mismatched types:
 expected `()`,
    found `core::result::Result<_, _>`
(expected (),
    found enum `core::result::Result`) [E0308]
<std macros>:5 return $ crate:: result:: Result:: Err (
<std macros>:6 $ crate:: convert:: From:: from ( err ) ) } } )
read_a_file.rs:5:17: 5:44 note: in this expansion of try! (defined in <std macros>)
<std macros>:5:8: 6:42 help: run `rustc --explain E0308` to see a detailed explanation
error: aborting due to previous error
```

Серьёзно? Я чувствую как я прыгнул в бассейн с Haskell, а затем выпил коктейль с
шаблонами ошибок на С++. Что это?

К счастью, после рассматривания этих строк я понял что подсказка кроется в этих
строчках:

```
expected `()`,
   found `core::result::Result<_, _>`
```

Получилось не соответствие типов. Наша функция `main` не возвращает какие-либо
значения, что равносильно возврату пустого кортежа `()`. Но макрос `try!`
работает лишь внутри функций которые возвращают `Result`. Впервые в жизни увидел
функцию в стиле языка Си, которая вызывается лишь внутри функции определенного
типа.

Мы можем легко наш пример исправить положив вызов `try!` в отдельную специальную
функцию:

```rust
use std::io;
use std::fs::File;

fn read_file() -> Result<(), io::Error> {
    let mut f = try!(File::open("foo.txt"));
    Ok(())
}
fn main() {
    read_file();
}
```

Когда я написал этот код, закрыл редактор и ушёл прочь с ощущением, что я родил
что-то чужеродное, неестественное, грубое.

Спустя пару недель я осознал, что этот подход к обработке ошибок гениален!

