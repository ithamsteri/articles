# Простое x86 ядро

**Оригинал статьи:** <http://os.phil-opp.com/multiboot-kernel.html>

В этой статье мы рассмотрим как сделать небольшое ядро операционной системы. Оно будет загружаться и выводить `OK` на экран. В следующих статьях мы продолжим писать ядро с помощью языка программирования [Rust](http://www.rust-lang.org/).

Я постараюсь рассказать о написании операционной системы как можно подробнее и писать простой понятный код. Если у вам возникли какие-либо вопросы, предложения или прочие проблемы, то можете писать в комментарии или (создать [issue](https://github.com/phil-opp/blog_os/issues)) на Github. Исходный код можно найти в моём [репозитории](https://github.com/phil-opp/blog_os/tree/multiboot_bootstrap/src/arch/x86_64).

Хочу заметить, что эта серия статей написана для работы в операционной системе Linux. В MacOS были замечены проблемы, которые можно посмотреть [здесь](https://github.com/phil-opp/blog_os/issues/55). Если вы хотите использовать виртуальную машину с Linux, то можете воспользоваться инструкцией и Vagrantfile в репозитории [Ashley Williams](https://github.com/ashleygwilliams/x86-kernel).

## Введение

Когда вы включаете компьютер, то сначала загружается [BIOS](https://ru.wikipedia.org/wiki/BIOS) со специального flash-накопителя (ПЗУ). BIOS запускает само-тестирование и инициализию оборудования. Затем производит поиск загружаемых устройств. Если такое устройство будет обнаружено, то загружается _загрузчик_ и передаётся ему управление. _Загрузчик_ - небольшой исполняемый код, хранящийся в загрузочной части устройства. Цель загрузчика - найти где расположено ядро операционной системы и загрузить его в оперативную память. Может также потребоваться переключить центральный процессор в защищённый режим, т.к. x86 совместимые процессоры запускаются в очень ограниченном [реальном режиме](http://wiki.osdev.org/Real_Mode) (для совместимости программ со времён 1978 года).

Мы не станем писать свой загрузчик, т.к. это большая сложная задача для нашего учебного проекта, но если вам всё же захочется написать, то можете прочитать статью [Rolling Your Own Bootloader](http://wiki.osdev.org/Rolling_Your_Own_Bootloader). Вместо этого мы воспользуемся одним из множества загрузчиков. Но которым?

## Multiboot

Тут нам повезло. Существаует стандарт для загрузчиков: [Multiboot спецификация](https://ru.wikipedia.org/wiki/Multiboot_Specification). Нам будет достаточно реализовать в ядре поддержку Multiboot и любой загрузчик поддерживающий стандарт Multiboot будет загружать наше ядро операционной системы. Мы будем использовать Multiboot 2 спецификацию ([PDF](http://nongnu.askapache.com/grub/phcoder/multiboot.pdf)), которая поддерживается в популярном загрузчике [GRUB 2](http://wiki.osdev.org/GRUB_2).

Чтобы показать, что наше ядро имеет поддержку Multiboot 2 нужно будет добавить _Mutliboot заголовок_ в начало ядра, который имеет следующий формат:

| Поле          | Тип             | Значение                                  |
| :----------- -| :-------------- | :---------------------------------------- |
| magic number  | u32             | `0xE85250D6`                              |
| architecture  | u32             | `0` для i386, `4` для MIPS                |
| header length | u32             | Весь размер заголовка, включая теги       |
| checksum      | u32             | `-(magic + architecture + header_length)` |
| tags          | variable        |                                           |
| end tag       | (u16, u16, u32) | `(0, 0, 8)`                               |

Напишем код на x86 ассемблере (Intel синтаксис):

```nasm
section .multiboot_header
header_start:
    dd 0xe85250d6                ; магическое число (multiboot 2)
    dd 0                         ; архитектура 0 (защищенный режим i386)
    dd header_end - header_start ; размер заголовка
    ; контрольная сумма
    dd 0x100000000 - (0xe85250d6 + 0 + (header_end - header_start))

    ; дополнительные теги multiboot добавляются сюда

    ; завершающий тег
    dw 0    ; тип
    dw 0    ; флаги
    dd 8    ; размер
header_end:
```

Если вы не знаете x86 ассемблера, то кратко о том что мы написали:

* заголовок будет располагаться в секции с именем `.multiboot_header` (он понадобится нам позже);

* Метки `header_start` и `header_end` отмечают адреса памяти, которые мы используем для получения размера заголовка;

* `dd` означает добавление 32-битного значения, а `dw` добавление 16-битного значения. С их помощью мы вставляем константы в выходной бинарный файл;

* При вычислении контрольной суммы мы добавили константу `0x100000000` для маленькой хитрости, чтобы компилятор не выводил предупреждений при компиляции. По формуле, приведённой в таблице, `-(magic + architecture + header_length)` мы получаем отрицательное значение, которое не влазит в 32 бита. Вычитая из `0x100000000` (`2` в `32` степени), мы получаем положительное значение, и оно влазит в 32-бита, и компилятор доволен. :)

Теперь мы можем скомпилировать файл (который я назвал `multiboot_header.asm`), используя компилятор `nasm`. В результате мы должны получить плоский двоичный файл, который будет содержать 24 байта (little-endian порядок битов, если вы работаете на x86-совместимой системе):

```bash
$ nasm multiboot_header.asm
$ hexdump -x multiboot_header
0000000    50d6    e852    0000    0000    0018    0000    af12    17ad
0000010    0000    0000    0008    0000
0000018
```

## Код ядра

Мы теперь добавим код который будет выполняться после загрузки ядра загрузчиком. Создадим файл с именем `boot.asm`:

```nasm
global start

section .text
bits 32
start:
    ; print `OK` to screen
    mov dword [0xb8000], 0x2f4b2f4f
    hlt

```

А теперь рассмотрим код поближе:

* `global` экспортирует метку (делает открытый доступ). Метка `start` у нас будет точкой входа в наше ядро;

* Секция `.text` является секцией по умолчанию для исполняемого кода;

* `bits 32` определяет разрядность инструкций, которые следуют после этой директивы. Эта директива нужна нам, т.к. GRUB перед запуском нашего ядра переводить центральный процессор в [Защищённый режим](https://ru.wikipedia.org/wiki/Защищённый_режим). В следующей статье мы будем переключаться в [Long режим](https://en.wikipedia.org/wiki/Long_mode), где будет использоваться директива `bits 64` (для использования 64-битных инструкций);

* Инструкция `mov dword` записывает 32-битную константу `0x2f4b2f4f` в память по адресу `0xb8000` (Это выведет `OK` на экран, об этом подробнее поговорим в следующей статье);

* Инструкция `hlt` останавливает работу центрального процессора.

Теперь соберём наш код, посмотрим что получилось и дисассемблируем файл, чтобы увидеть коды [операций](https://ru.wikipedia.org/Код_операции):

```bash
$ nasm boot.asm
$ hexdump -x boot
0000000    05c7    8000    000b    2f4b    2f4f    00f4
000000b
$ ndisasm -b 32 boot
00000000  C70500800B004B2F  mov dword [dword 0xb8000],0x2f4b2f4f
         -4F2F
0000000A  F4                hlt
```

## Сборка ядра

GRUB требует, чтобы ядро было исполняемым файлом в формате [ELF](https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format). Нужно `nasm` сообщить о том, что нужно сделать ELF [объектный файл](http://wiki.osdev.org/Object_Files) вместо плоского двоичного файла. Для нужно лишь добавить аргумент `-f elf64` к вызову компилятора.

Для создания ELF исполняемого файла нам нужно [скомпоновать](https://ru.wikipedia.org/wiki/Компоновщик) объектные файлы вместе. Для этого мы напишем [скрипт для компоновщика](https://sourceware.org/binutils/docs/ld/Scripts.html) `linker.ld`:

```
ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        /* Мы должны быть уверены, что multiboot заголовок будет вначале файла */
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
```

Рассмотрим код поближе:

* `start` у нас точка входа. Загрузчик будет передавать управление туда после загрузки ядра в память;

* `. = 1M` указываем адрес в памяти куда будет выполнена загрузка первой секции ядра загрузчиком. Это сделано для того чтобы защитить специальную область памяти которая находится в первом мегабайте оперативной памяти (например, VGA буфер расположен по адресу `0xb800`, куда мы выводим `OK` на экран);

* Исполняемый файл имеет две секции: `.boot` который будет вначале перед секцией `.text`;

* На выходе секция `.text` будет содержать в себе секции `.text` в входящих файлах;

* Во входящих объектных файлах данные из секции `.multiboot_header` будут добавлены в выходную секцию `.boot`, которая будет расположена сразу после ELF заголовка в исполняемом файле, т.к. GRUB будет искать Multiboot заголовок в этом месте.

Давайте сделаем ELF объектные файлы и скомпонуем их, используя наш скрипт для компоновки. Важно указать аргумент `-n` компоновщику, который отключит автоматическое выравнивание секций в выходном исполняемом файле. Иначе компоновщик может выровнять секцию `.boot`, то тогда GRUB не сможет найти Multiboot заголовок, т.к. он будет не сразу после ELF заголовка в исполняемом файле. Мы можем воспользоваться `objdump` для отображения секций сгенерированного исполняемого файла и проверить, что секция `.boot` ...:

```bash
$ nasm -f elf64 multiboot_header.asm
$ nasm -f elf64 boot.asm
$ ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
$ objdump -h kernel.bin
kernel.bin:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .boot         00000018  0000000000100000  0000000000100000  00000080  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000000b  0000000000100020  0000000000100020  000000a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
```

_Примечание:_ утилиты `ld` и `objdump` платформо-зависимы. Если вы работаете не на машине с x86_64 архетиктурой, то нужно воспользоваться `binutils` [собранным](http://os.phil-opp.com/cross-compile-binutils.html) для x86_64. Затем использовать утилиты `x86_64-elf-ld` и `x86_64-elf-objdump` вместо `ld` и `objdump`.

## Созадаём ISO образ

Последний шаг - создание загрузочного ISO образа с GRUB загрузчиком. Нам нужно создать структуру каталогов и скопировать `kernel.bin` в правильное место:

```
isofiles
└── boot
    ├── grub
    │   └── grub.cfg
    └── kernel.bin
```

Файл `grub.cfg` задаёт имя файла с нашим ядром и укзанием поддерки Multiboot 2:

```
set timeout=0
set default=0

menuentry "my os" {
    multiboot2 /boot/kernel.bin
    boot
}
```

Сейчас мы можем сделать загрузочный образ, используя комманду:

```bash
grub-mkrescue -o os.iso isofiles
```

_Примечание:_ Если у вас эта команда не работает, то проверьте установлен ли у вас `xorriso` и попытайтесь добавить к команде аргумент `--verbose`.

## Загрузка

Пора попробовать загрузить нашу операционную систему. Для этого мы воспользуемся [QEMU](https://ru.wikipedia.org/wiki/QEMU):

```bash
qemu-system-x86_64 -drive format=raw,file=os.iso
```

![Наша ОС в QEMU](http://os.phil-opp.com/images/qemu-ok.png)

Обратите внимание на зелёный `OK` в верхнем левом углу.

А теперь по-порядку о том, что происходит:

1. BIOS загружает загрузчик (GRUB) с виртуального жесткого диска (ISO образ);

2. Загрузчик читает исполняемый файл ядра и находит Multiboot заголовок;

3. Копирует секции `.boot` и `.text` в память (адресу в памяти `0x100000` и `0x100020`);

4. Передаёт управление в точку входа (`0x1000020`, вы можете это узнать с помощью `objdump -f`);

5. Наше ядро выводит зелёное `OK` на экран и останавливает работу центрального процессора.

Вы можете протестировать нашу ОС на настоящем железе. Запишите ISO образа на CD/DVD или на флеш-накопитель и загрузитесь с него.

## Автоматическая сборка

Сейчас нам нужно выполнить 4 команды по порядку каждый раз когда мы изменяем код. Это очень не удобно. Мы можем автоматизировать сборку используя [Makefile](http://mrbook.org/blog/tutorials/make/). Для начала мы сделаем дерево каталогов более чище, отделив архитектуро-зависимые файлы:

```
…
├── Makefile
└── src
    └── arch
        └── x86_64
            ├── multiboot_header.asm
            ├── boot.asm
            ├── linker.ld
            └── grub.cfg
```

Makefile выглядит так (отступы вместо пробелов должны быть табуляцией):

```Makefile
arch ?= x86_64
kernel := build/kernel-$(arch).bin
iso := build/os-$(arch).iso

linker_script := src/arch/$(arch)/linker.ld
grub_cfg := src/arch/$(arch)/grub.cfg
assembly_source_files := $(wildcard src/arch/$(arch)/*.asm)
assembly_object_files := $(patsubst src/arch/$(arch)/%.asm, \
    build/arch/$(arch)/%.o, $(assembly_source_files))

.PHONY: all clean run iso

all: $(kernel)

clean:
    @rm -r build

run: $(iso)
    @qemu-system-x86_64 -drive format=raw,file=$(iso)

iso: $(iso)

$(iso): $(kernel) $(grub_cfg)
    @mkdir -p build/isofiles/boot/grub
    @cp $(kernel) build/isofiles/boot/kernel.bin
    @cp $(grub_cfg) build/isofiles/boot/grub
    @grub-mkrescue -o $(iso) build/isofiles 2> /dev/null
    @rm -r build/isofiles

$(kernel): $(assembly_object_files) $(linker_script)
    @ld -n -T $(linker_script) -o $(kernel) $(assembly_object_files)

# compile assembly files
build/arch/$(arch)/%.o: src/arch/$(arch)/%.asm
    @mkdir -p $(shell dirname $@)
    @nasm -felf64 $< -o $@
```

Поговорим об этом Makefile немного:

* `$(wildcard src/arch/$(arch)/*.asm)` выбирает все `*.asm` файлы в `src/arch/$(arch)` каталоге. Так можно добавить еще файлов в этот каталог без изменения Makefile.

* Операция `patsubst` для `assembly_source_files` делает из `src/arch/$(arch)/XYZ.asm` в `build/arch/$(arch)/XYZ.o`;

* В сборке `*.asm` файлов `$<` и `$@` являются [автоматическими переменными](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html):

Сейчас мы можем вызвать `make` и все изменённые файлы будут скомпилированы и скомпонованы. Вызвав `make iso`, создадим ISO образ и `make run` запустит QEMU.

## Что дальше?

В следующей статье мы создадим таблицу страниц и переключим центральный процессор в 64-битный [Long режим](https://en.wikipedia.org/wiki/Long_mode).
