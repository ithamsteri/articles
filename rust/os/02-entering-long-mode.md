# Переход в Long режим

В предыдущей статье мы сделали небольшое ядро, которое выводит `OK` и останавливает центральный процессор. На данный момент после загрузки ядра, центральный процессор находится в [защищённом режиме](https://ru.wikipedia.org/wiki/Защищённый_режим) и позволяет исполнять только 32-битные инструкции и адресация оперативной памяти ограничена 4Гб. Наша задача доработать ядро и позволить выполнять 64-битные инструкции для использования в ядре кода на языке Rust, а также настроить _страничную организацию памяти_.

Я постараюсь рассказать о написании операционной системы как можно подробнее и писать простой понятный код. Если у вам возникли какие-либо вопросы, предложения или прочие проблемы, то можете писать в комментарии или (создать [issue](https://github.com/phil-opp/blog_os/issues)) на Github. Исходный код можно найти в моём [репозитории](https://github.com/phil-opp/blog_os/tree/entering_longmode/src/arch/x86_64).

## Немного проверок

Чтобы у нас не было проблем и ошибок со старыми центральными процессорами, нужно сделать ряд проверок. Если процессор нам не подойдёт, то выведем на экран сообщение об ошибке. Обработать ошибку просто, лишь создав процедуру в файле `boot.asm`, которая выведет на экран сообщение типа `ERR: X`, где X будет кодом ошибки, и остановит работу центрального процессора:

```nasm
; Выводит `ERR: ` и выводит код ошибки на экран, а после останавливает ЦП.
; параметр: код ошибки (в ASCII коде) в регистре al
error:
    mov dword [0xb8000], 0x4f524f45
    mov dword [0xb8004], 0x4f3a4f52
    mov dword [0xb8008], 0x4f204f20
    mov byte  [0xb800a], al
    hlt

```

По адресу `0xb8000` начинается, так называемый, [VGA текстовый буфер](https://en.wikipedia.org/wiki/VGA-compatible_text_mode). Это массив символов отображаемые графической картой. В следующих статьях мы рассмотрим VGA буфер более детально и сделаем интерфейс к нему на Rust. Но сейчас нам проще вручную в буфер поместить коды символов.
