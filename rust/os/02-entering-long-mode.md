# Переход в Long режим

В предыдущей статье мы сделали небольшое ядро, которое выводит `OK` и останавливает центральный процессор. На данный момент после загрузки ядра, центральный процессор находится в [защищённом режиме](https://ru.wikipedia.org/wiki/Защищённый_режим) и позволяет исполнять только 32-битные инструкции и адресация оперативной памяти ограничена 4Гб. Наша задача доработать ядро и позволить выполнять 64-битные инструкции для использования в ядре кода на языке Rust, а также настроить _страничную организацию памяти_.

Я постараюсь рассказать о написании операционной системы как можно подробнее и писать простой понятный код. Если у вам возникли какие-либо вопросы, предложения или прочие проблемы, то можете писать в комментарии или (создать [issue](https://github.com/phil-opp/blog_os/issues)) на Github. Исходный код можно найти в моём [репозитории](https://github.com/phil-opp/blog_os/tree/entering_longmode/src/arch/x86_64).

## Немного проверок

Чтобы у нас не было проблем и ошибок со старыми центральными процессорами, нужно сделать ряд проверок. Если процессор нам не подойдёт, то выведем на экран сообщение об ошибке. Обработать ошибку просто, лишь создав процедуру в файле `boot.asm`, которая выведет на экран сообщение типа `ERR: X`, где X будет кодом ошибки, и остановит работу центрального процессора:

```nasm
; Выводит `ERR: ` и выводит код ошибки на экран, а после останавливает ЦП.
; параметр: код ошибки (в ASCII коде) в регистре al
error:
    mov dword [0xb8000], 0x4f524f45
    mov dword [0xb8004], 0x4f3a4f52
    mov dword [0xb8008], 0x4f204f20
    mov byte  [0xb800a], al
    hlt

```

По адресу `0xb8000` начинается, так называемый, [VGA текстовый буфер](https://en.wikipedia.org/wiki/VGA-compatible_text_mode). Это массив символов отображаемые графической картой. В следующих статьях мы рассмотрим VGA буфер более детально и сделаем интерфейс к нему на Rust. Но сейчас нам проще вручную в буфер поместить коды символов.

Экранный символ состоит из 8-битного цветовой кода и 8-битного [ASCII](https://ru.wikipedia.org/wiki/ASCII) кода символа. Мы используем цветовой код `4f`, который обозначает белый текст на красном фоне. `0x52` это ASCII код символа `R`, `0x45` - `E`, `0x3a` - `:`, и `0x20` - пробел. Второй пробел перезаписывается полученным ASCII байтом. В конце останавливаем центральный процессор инструкцией `hlt`.

Теперь мы будем добавлять _функции_ проверок. Функция это простая метка с инструкцией `ret` (возврат) в конце. Инструкция `call` позволяет вызывать функции. Если сравнивать инструкции `jmp` и `call`, то `jmp` просто прыгает по адресу в памяти, а `call` сначала кладёт в стек и затем прыгает. Инструкция `ret` достаёт адрес из стека и делает прыжок по данному адресу. Но у нас сейчас нет стека. Регистр `esp` является [указателем на стек](http://stackoverflow.com/a/1464052/866447), который указывает сейчас неизвестно куда в память. Сейчас необходимо задать указатель на стек и дать стеку память для хранения данных.

### Создание стека

Выделим память для стека, зарезервировав байты в конце файла `boot.asm`:

```nasm
...
section .bss
stack_bottom:
    resb 64
stack_top:
```

Нам не нужно инициализировать стек, т.к. мы будем доставать данные после того как туда что-то положили. Стек нам для ядра не нужен большой. В секции [`.bss`](https://en.wikipedia.org/wiki/.bss) указываем с помощью `resb`, что хотим зарезервировать неинициализированные данные длиной 64 байта. Когда GRUB будет загружать наше ядро, то создаст секцию требуемого размера в памяти.

Для того чтобы начать использовать стек, нужно в самом начале кода ядра присвоить регистру `esp` верхний адрес стека:

```nasm
global start

section .text
bits 32
start:
    mov esp, stack_top

    ; выводим `OK` на экран
    ...

```

Мы указываем `stack_top`, а не `stack_bottom`, т.к. стек растёт сверху вниз. Инструкция `push eax` вычитает 4 из `esp` и копирует занчение из `eax` в стек: `mov [esp], eax` (`eax` это регистр общего назначения).

У нас теперь есть работающий стек и мы можем совершать вызовы функций. Далее мы напишем функции проверок. Если проверка провалилось, то переходим на метку `error`. Не будем вдаваться в подробности работы этих проверок.

### Проверка Multiboot

Нам понадобятся возможности Multiboot в последующих статьях. Нужно удостовериться, что ядро действительно загружено загрузчиком, поддерживающим Multiboot спецификацию ([PDF](http://nongnu.askapache.com/grub/phcoder/multiboot.pdf)). Для этого нужно всего лишь проверить регистр `eax`, который должен содержать "магическое" значение `0x36d76289`. Для проверки напишем простую функцию:

```nasm
test_multiboot:
    cmp eax, 0x36d76289
    jne .no_multiboot    ; jne - "прыжок, если не равно"
    ret
.no_multiboot:
    mov al, "0"
    jmp error
```

Здесь мы сравниваем "магическое" значение со значением в `eax`. Если значения не совпадают, то мы прыгаем на метку "no_multiboot", где мы прыгаем в функцию вывода ошибки с кодом ошибки `0`. 

### Проверка CPUID

[CPUID](http://wiki.osdev.org/CPUID) это инструкция центрального процессора которая используется для получения различной информации о процессоре. Не каждый процессор поддерживает эту инструкцию. Проверка на наличие CPUID инструкции достаточно сложна, так что просто скопируем код с [вики OSDev](http://wiki.osdev.org/Setting_Up_Long_Mode#Detection_of_CPUID):

```nasm
test_cpuid:
    pushfd               ; Кладём в стек регистр FLAGS.
    pop eax              ; Достаём из стека значение в регистр A.
    mov ecx, eax         ; Копируем значение из регистра A в регистр C.
    xor eax, 1 << 21     ; Инвертируем ID-бит (21 бит).
    push eax             ; Кладём в стек регистр A.
    popfd                ; Достаём из стека в регистр FLAGS.

    pushfd               ; Store the FLAGS-register.
    pop eax              ; Restore the A-register.
    push ecx             ; Store the C-register.
    popfd                ; Restore the FLAGS-register.
    xor eax, ecx         ; Do a XOR-operation on the A-register and the C-register.
    jz .no_cpuid         ; The zero flag is set, no CPUID.
    ret                  ; Процессор поддерживает инструкцию CPUID.
.no_cpuid:
    mov al, "1"
    jmp error
```

### Проверка поддержки Long режима

Сейчас нам понадобится CPUID для определения поддержки центральным процессором Long режима. Я взял код с [OSDev](http://wiki.osdev.org/Setting_Up_Long_Mode#x86_or_x86-64) снова:

```nasm
test_long_mode:
    mov eax, 0x80000000    ; Присваиваем значение 0x80000000 регистру A.
    cpuid                  ; Получение информации о центральном процессоре.
    cmp eax, 0x80000001    ; Сравниваем регистр A с значением 0x80000001.
    jb .no_long_mode       ; Если меньше, то нет поддержки Long режима.
    mov eax, 0x80000001    ; Присваиваем значение 0x80000001 регистру A.
    cpuid                  ; Получение информации о центральном процессоре.
    test edx, 1 << 29      ; Проверяем, если LM-бит (29 бит) установлен в 1
                           ; в регистре D.
    jz .no_long_mode       ; Если нет, то нет поддержки Long режима.
    ret
.no_long_mode:
    mov al, "2"
    jmp error
```

### Используем проверки

Мы вызываем эти функции с проверками после настройки стека:

```nasm
global _start

section .text
bits 32
_start:
    mov esp, stack_top

    call test_multiboot
    call test_cpuid
    call test_long_mode

    ; выводим `OK` на экран
    ...

```

Если центральный процессор не поддерживает нужные возможности, то мы получим сообщение об ошибке с уникальным кодом ошибки. Теперь займемся настоящей работой.

## Страничная организация памяти

Страничная организация памяти делится на виртуальную и физическую память. Адресное пространство делится на равные по размеру _страницы_. _Таблица страниц_ определяет какие страницы указывают на какую область физической памяти. Если вы до этого не сталкивались до этого со страничной организацией памяти, то советую почитать введение в страничную организацию памяти ([PDF](http://pages.cs.wisc.edu/%7Eremzi/OSTEP/vm-paging.pdf)) из книги [Three Easy Pieces](http://pages.cs.wisc.edu/%7Eremzi/OSTEP/).

В Long режиме x86 процессора используется размер страниц 4096 байт (4 килобайта) и 4-х уровневую таблицу страниц, состоящую из:

* Page-Map Level-4 таблица (PML4);

* Page-Directory Pointer таблица (PDP);

* Page-Directory таблица (PD);

* Таблица страниц (PT).

Мне не нравятся эти имена и я в дальнейшем буду называть их так: P4, P3, P2 и P1.

Каждая таблица содержит 512 записей по 8 байт каждая, поэтому одна таблица может занимать ровно одну страницу (`512*8 = 4096`). Центральный процессор преобразовывает виртуальный адрес в физический следующим образом:

![Преобразование виртуального адреса в физический](http://os.phil-opp.com/images/X86_Paging_64bit.svg)

1. Получаем адрес P4 таблицы из регистра `cr3`;

2. Используем 39-47 биты (9 бит) как индекс в P4 таблице (`2^9 = 512 = количество записей`);

3. Используем следующие 9 бит как индекс в P3 таблице;

4. Используем следующие 9 бит как индекс в P2 таблице;

5. Используем следующие 9 бит как индекс в P1 таблице;

6. Используем последние 12 бит как смещение страницы (`2^12 = 4096 = размер страницы`).

Для чего же 48-63 биты в 64-битном виртуальном адресе? Они не используются! "64-битный" Long режим по-факту является 48-битным режимом. Также требуется биты 48-63 должны быть такими же как у 47 бита, иначе процессор будет выдавать исключение. Подробнее можно найти на [Wikipedia](https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details).

> В процессорах с x86 архитектурой управление страницами возлагается на сам процессор, который сам преобразовывает виртуальные адреса в физические через таблицы страниц. В других архитектурах процессоров, например MIPS, просто выбрасывается исключение и операционная система сама преобразовывает виртуальные адреса в физические.
