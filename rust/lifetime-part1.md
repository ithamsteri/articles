# Время жизни в Rust (Часть 1)

## Введение

В этом цикле статей я хочу рассказать вам о времени жизни в Rust. Эта тема очень
трудна для понимания для тех кто только начал изучать Rust. Первое время идёт
борьба с компилятором и недопонимание, но опыт приходит со временем. Мы
рассмотрим то, как работает время жизни в Rust на практических примерах для
большего понимания.

## Постановка задачи

Мы будем разрабатывать структуру с именем `Logger`, которая будет хранить в себе
текстовые данные и предоставляющая доступ к своим данным только для чтения.

## Пишем код

Давайте напишем код для выполнения задачи:

```rust
pub struct Logger {
    log: String
}

// Реализация методов для структуры Logger
impl Logger {
    pub fn new() -> Logger {
        Logger{ log: String::new() }
    }

    // Метод добавления текста в лог
    pub fn addText(&mut self, data: &str) {
        self.log.push_str(data);
    }
}

fn main() {
    let mut logger = Logger:new();

    logger.addText("foo");
    logger.addText("bar");
}
```

Этот код правильный и компилируется. Сделали всё, что требовалось задачей, кроме
доступа к текстовым данным. Что собственно сейчас и начнём делать.

## Предоставляем чтение данных

Рассмотрим 3 варианта как предоставить пользователю нашей структуры прочитать
данные хранящиеся в ней.

### Вариант 1: Клонирование данных

Самый простой вариант. Просто клонируем данные и возвращаем их пользователю:

```rust
impl Logger {
    // ... методы структуры Logger ...

    pub fn get_log_clone(&self) -> String {
        self.log.clone()
    }
}
```

Теперь вызвав этот метод можно получить текст с данными. В этом варианте сначала
выделяется участок памяти способный вместить все данные, хранящиеся в `log`.
Затем копируются все данные в новый участок и только тогда передаются
пользователю.

Этот вариант в плане производительности ужасен! Особенно это будет заметно при
работе с длинными текстовыми данными. Нам этот вариант не подходит, т.к. мы
хотим большей производительности и Rust нам может дать её.

### Вариант 2: Копирование

А что если мы попробуем не клонировать данные, а лишь вернуть копию данных. При
копировании данных не выделяется новый участок данных, а передается указатель на
старые данные. Это могло бы сэкономить на выделении памяти и переносе данных.
Давайте попробуем сделать это:

```rust
impl Logger {
    // ... методы структуры Logger ...

    pub fn get_log_copy(&self) -> String {
        self.log
    }
}

fn main() {
    let mut logger = Logger::new();
    let my_log = logger.log_copy();
}
```

Увы, но наш код не компилируется. Всё из-за того что мы пытаемся передать _право
владения_ внутренней переменной структуры `Logger` пользовательской переменной
`my_log`. Передав
[владение](https://kgv.gitbooks.io/rust_book_ru/content/src/ownership.html) в
`my_log` внутренняя переменная становится не доступной, т.е. методы нашей
структуры не смогут пользоваться ей. Ужасная ситуация получается!  Поэтому в
нашем случае Rust запрещает передавать владение внутренних переменных структур.
Так что этот второй вариант также нам не подходит.

_Право владения_ в Rust помогает избавиться от _проблемы повторного освобождения
ресурса ("Double free problem")_. Как мы уже знаем, что когда переменная выходит
из области видимости она освобождается. Если бы не было права владения, то
текстовые данные были бы освобождены дважды: первый раз когда переменная
`my_log` выйдет из области видимости и второй раз при выходе области переменной
`logger` с нашей структурой.

### Вариант 3: передача ссылки на данные

В этом варианте мы будет передавать пользователю ссылку на наши данные. Это не
потребует ресурсоёмких затрат и будет работать очень-очень быстро. Этот вариант
отлично нам подойдёт.

```rust
impl Logger {
    // ... прочие методы Logger ...

    pub fn get_log(&self) -> &String {
        &self.text
    }
}

fn main() {
    let mut logger = Logger::new();

    logger.add_text('foo');
    logger.add_text('baz');

    // Получаем указатель на текст с данными
    let my_log = logger.get_log();  // Тип: &String

    println!("{}", my_log);
}
```

Вот тут бы я хотел остановиться и обсудить время жизни. В этом коде мы
используем время жизни даже не зная об этом. 

Рассмотрим проблему. Наша структура дала нам ссылку на текст и после этого она
вышла из области видимости, что приведёт к её уничтожению. Куда будет теперь
указывать полученная ссылка? Ссылка стала указывать на удалённую область памяти
куда уже записали другие данные, например. 

Чтобы таких ситуаций не случалось в Rust применили систему времени жизни. В
нашем примере компилятор сам догадался без нашей помощи, что `logger` должен
быть уничтожен после полученной ссылки `my_log`.

Давайте воспользуемся полученной ссылкой после уничтожения нашей структуры:

```rust
fn main() {
    let my_log;

    {
        let mut logger = Logger::new();

        logger.add_text("foo");
        logger.add_text("baz");

        my_log = logger.get_log();
    } // Конец времени жизни для logger

    println!("{}", my_log); // ОШИБКА!
}
```

В этом случае нам компилятор запретит так делать, т.к. `my_log` будет ссылаться
на уничтоженный участок памяти.

## Параметры времени жизни

Часто компилятор будет сам обозначать время жизни без нашего участия. Он легко
определяет, что указатель на строку `&String` передаётся из `&self`. Это
означает, что время жизни у `&self` должна быть больше чем у возвращаемого
указателя на строку, хранящейся в ней. Такие простые случаи компилятор не
требует от нас явного указания времени жизни, т.к. он сам способен определить
время жизни. Но нам ничто не мешает вручную указать параметры времени жизни:

```rust
impl Logger {
    // ... прочие методы Logger ...

    pub gn get_log<'a>(&'a self) -> &'a String {
        &self.log
    }
}
```

Вот так мы указываем параметры времени жизни. В нашем примере мы использовали
`a` как параметр времени жизни. В реальных проектах вы будете часто встречать
параметры времени жизни обозначенные латинскими буквами: `a`, `b`, `c`, `d` и
т.д. Но ничто нам не запрещает выбрать для параметра времени жизни любое другое
имя, например `my_super_lifetime`.

В `get_log<'a>` мы объявляем имена времён жизни. Мы будем использовать одно
время жизни `a`.

В `(&'a self)` мы определяем, что у `&self` время жизни должно быть равным `a`.

В `&'a String` мы указываем, что переменная получившая указатель на строку
должна иметь время жизни такую же как у нашей структуры, т.е. равной `a` или
иметь меньшее время жизни, чтобы указатель всегда ссылался на существующие
данные в нашей структуре.

## Проверка на заимствование

Даже если мы правильно укажем параметры времени жизни, то можно столкнуться с
указателем на уже освобождённую строку, т.к. наша структура может освободить
внутреннюю переменную `log`. Тогда наша переменная `my_log` будет ссылаться на
удалённые данные в памяти. Добавим ещё один метод в нашу структуру:

```rust
impl Logger {
    // ... прочие методы ...

    pub fn reset(&mut self) {
        self.log = String::new();
    }
}
```

А теперь попробуем освободить строку в нашей структуре, заменив её новой
строкой:

```rust
let mut logger = Logger::new();

logger.add_text("foo");
logger.add_text("bar");

let my_log = logger.get_log();

logger.reset();

println!("{}", my_log); // А старой строки уже в памяти нет! ОШИБКА!
```

Переменная `my_log` содержащая в себе указатель на строку после вызова метода
`reset()` станет указывать на освобождённый участок памяти, что может привести к
большим проблемам в работе программы. К счастью, нас в такой ситуации спасает
_проверка на заимствование (borrow check)_.

Проверка на заимствование работает следующим образом: переменная `my_log`
_заимствует_ неизменяемую ссылку на переменную `log` в нашей структуре, а также
заимствуем ссылку на родителя переменной, т.е. переменную `logger`. После этого
мы вызываем метод `reset()`, который пытается позаимствовать изменяемую ссылку
для `logger`. Здесь произойдёт ошибка заимствования, т.к. нарушено правило
заимствования.

*Правила заимствования:*

* Чтобы позаимствовать *изменяемую ссылку* требуется чтобы никто не заимствовал
    неизменяемую или изменяемую ссылку до этого.

* Чтобы позаимствовать *неизменяемую ссылку* требуется чтобы никто не
    заимствовал изменяемую ссылку до этого.

## Другие языки программирования

Если вам приходилось сталкиваться с языками программирования типа Java или
Objective-C, то вас удивит использование времени жизни в Rust. В Java
используется сборщик мусора (Garbage Collector) для осбобождения памяти от не
используемых объектов, переменных. В нашем примере Java не освобождал бы
переменную `log` пока кто-то ссылается на неё. Objective-C ведёт подсчёт
количества ссылок на участок памяти. В нашем примере есть 2 ссылки на участок
памяти где хранится строка: первая ссылка это переменная `log` внутри нашей
структуры и вторая ссылка это переменная `my_log`. В Objective-C участок памяти
с текстовыми данными может быть освобождён лишь когда эти ссылки перестанут
ссылаться на данные и тогда счётчик ссылок станет равен 0.

Сборщик мусора требует дополнительных вычислительных затрат процессора и памяти,
а главное требует паузы программы для освобождения не нужных данных в памяти.
Подсчёт ссылок также требует дополнительных вычислительных затрат. Время жизни в
Rust предлагает решение без использования дополнительных вычислительных затрат.

