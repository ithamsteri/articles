# Время жизни в Rust (Часть 1)
 
  > [Оригинал статьи](https://mobiarch.wordpress.com/2015/06/29/understanding-lifetime-in-rust-part-i/)
 
Я считаю, что бо́льшую часть времени при изучении Rust уходит на то, как работает в Rust время жизни. Если мы отвлечёмся от Foreign Function Interface (FFI) на несколько секунд, то остальная часть языка проста.

Я планирую сделать серию статей о времени жизни в Rust. В этой первой части мы рассмотрим простое применение для время жизни на практике.

## Постановка задачи

Мы будем разрабатывать простой тип для текстового редактора под названием `TextEditor`. Он будет содержать закрытое поле типа `String`. Пользователи этого типа должны иметь возможность получить доступ только для чтения текста без прямого его изменения.

## Начинаем!

Давайте начнём писать код:

```rust
pub struct TextEditor {
    text: String // Закрытое поле от пользователя типа
}
 
impl TextEditor {
    pub fn new() -> TextEditor {
        TextEditor{text: String::new()}
    }
 
    // Изменяем текст
    pub fn add_char(&mut self, ch : char) {
        self.text.push(ch);
    }
}
 
fn main() {
    let mut editor = TextEditor::new();
 
    editor.add_char('a');
    editor.add_char('b');
    editor.add_char('c');
}
```

Этот код должен компилироваться. Он функционален за исключением возможности получения текста из `TextEditor`.

## Даём возможность чтения текста

Хорошо, сейчас нам нужно добавить метод в `TextEditor` для того чтобы дать доступ для чтения текста через текстовую переменную. У нас есть несколько вариантов как это можно сделать:

### Вариант 1 – Клонирование

Клонируем текстовую переменную и возвращаем её копию.

```rust
pub fn get_text_clone(&self) -> String {
    self.text.clone()
}
```

Клонирование выделяет новый участок памяти для текста и копирует в этот участок все символы строки. Этот вариант легко реализовать, но будет использовать затраты памяти и процессорного времени при клонировании. Особенно это будет заметно при большом количестве текста. Такой подход используется в Java классах. Но мы же в мире Rust! Нам надо максимум производительности!

### Вариант 2 – Копирование

Второй вариант не совсем вариант, т.к. Rust просто не позволит нам так сделать. Просто обсудим его для полноты раскрытия темы. Что если мы захотели скопировать нашу переменную с текстом. Копирование указателя на строку не выделяет нового участка памяти для нашего текста, так что мы сэкономим память. Что если мы напишем так:

```rust
pub fn get_text_copy(&self) -> String {
    self.text
}
 
// Получаем копию указателя на текст
let my_txt = editor.get_text_copy();
```

Rust не позволит скомпилировать этот код, т.к. здесь _право владения (ownership)_ переменной с нашим текстом передаётся в переменную `my_txt`. Теперь методы типа `TextEditor` не смогут больше получать доступ к тексту через `self.text` . Ужасная ситуация! В Rust передача _права владения_ решает проблему _"повторного освобождения" ("Double Free")_. Без права владения память выделенная для `String` освободилась бы дважды: первый раз когда `my_txt` вышла бы из области видимости и второй раз когда переменная `editor` вышла из области видимости.

### Вариант 3 – Возврат ссылки

В этом варианте мы обираемся вернуть указатель на переменную с текстом. Это будет молниеносно быстро. Ссылка будет не изменяема, т.к. пользователь будет иметь доступ только для чтения. Это отличное решение проблемы.

```rust
impl TextEditor {
    // Опустим прочие методы ...
 
    pub fn get_text(&self) -> &String {
        return &self.text;
    }
}
 
fn main() {
	let mut editor = TextEditor::new();
 
	editor.add_char('a');
	editor.add_char('b');
	editor.add_char('c');
 
	// Получаем указатель на переменную с текстом
	let my_txt = editor.get_text();
 
	println!("{}", my_txt);
}
```

----------

Этот код выглядит легким для понимания, но что же там происходит "под капотом"? Вы в этом коде уже используете время жизни даже не зная об этом.

Здесь появляется огромная проблема когда мы возвращаем ссылку на переменную с текстом. Что произойдет если переменная `editor` выйдет из области видимости и освободится, а переменная `my_txt` продолжит существовать? Тогда `my_txt` будет указывать на переменную типа `String`, память которой уже была освобождена, что приведёт к проблеме.

Здесь время жизни приходит к нам на помощь. Компилятор сам без нашей помощи применяет аннотации времени жизни таким образом, чтобы переменная `editor` должна освободиться позже переменной `my_txt` так, чтобы не возникла проблема использования переменной после её освобождения.

Ниже мы создадим ситуацию, где попытаемся использовать переменную после освобождения. Но компилятор нам это не позволит сделать.

```rust
let my_txt;
 
{
    let mut editor = TextEditor::new();
 
    editor.add_char('a');
    editor.add_char('b');
    editor.add_char('c');
 
    my_txt = editor.get_text();
} // Переменная editor освобождается здесь.
 
println!("{}", my_txt); // Использование после освобождения. ОПАСНОСТЬ!
```

## Аннотация времени жизни

Компилятор может сам определять аннотации времени жизни для нас в общих случаях. Он легко определяет что возвращаемый `&String` передаётся из `&self`. Следовательно время жизни у `&self` должна быть больше чем у хранимой в ней возвращаемой ссылке `&String`. Это автоматическое определение времени жизни называется **элизией**. Компилятор Rust'а может сам определять такие типичные случаи времени жизни переменных. Мы также можем вручную задавать аннотации времени жизни:

```rust
impl TextEditor {
    // Опустим прочие методы ...
 
    pub fn get_text<'a>(&'a self) -> &'a String {
        return &self.text;
    }
}
```

Так мы задаём продолжительность существования или время жизни. Не обязательно использовать `a` для указания времени жизни, можно например `b` или `my_grandma`. Но всё же принято обозначать время жизни одной латинской буквой: `a`, `b`, `c` и т.д.

В **`get_text<‘a>`** мы задаём имя для времени жизни буквой `a`.

В **`(&’a self)`** мы сообщаем что `&self` имеет время жизни равной `a`.

В **`&’a String`** мы указываем, что любая переменная какая хранит в себе эту ссылку должна иметь время жизни равную `a` или меньше.

## Проверка на заимствование

Но даже после правильного указания времени жизни есть возможность встретиться с проблемой "использования после освобождения". Что если тип `TextEditor` сам решит освободить переменную на которую ссылается переменная `my_txt`? Тогда она будет указывать на освобожденный участок памяти. Давайте добавим ещё один метод в `TextEditor`:

```rust
impl TextEditor {
    // Опустим прочие методы ...
 
    pub fn reset(&mut self) {
        self.text = String::new();
    }
}
```

Теперь попробуем сделать что-нибудь глупое, например вот так:

```rust
let mut editor = TextEditor::new();
 
editor.add_char('a');
editor.add_char('b');
editor.add_char('c');
 
let my_txt = editor.get_text();
 
editor.reset();
 
println!("{}", my_txt); // Использование после освобождения. ОПАСНОСТЬ!
```

Указатель `my_txt` после вызова `reset()` станет указывать на освобождённый участок памяти, что приведёт к предвиденным проблемам. К счастью, нас спасёт и наши нервы при поиске проблемы в коде – _проверка на заимствование (borrow check)_. Это работает следующим образом.

Переменная `my_txt` _заимствует_ ссылку на переменную с текстом. Также косвенно мы заимствуем ссылку на переменную `editor` (А также заимствует родителя, если заимствует любую его переменную содержащуюся в нём). Затем мы вызываем `editor.reset()` которая хочет позаимствовать изменяемую ссылку на `editor`. Здесь произойдет нарушение заимствования – чтобы позаимствовать изменяемую ссылку требуется чтобы никакая другая переменная не заимствовала изменяемую или не изменяемую ссылку до этого. Вот поэтому этот код не компилируется. Уфффф!

## Другие языки

Если вы сталкивались с другими языками типа Java или Objective-C, то вас удивит то, почему вам нужно работать с временем жизни в Rust. Для этого есть очень хорошие причины. В Java проблема "преждевременного освобождения" решается с помощью _сборщика мусора (Garbage Collection)_. Сборщик мусора в нашем случае не освобождал перемененную типа `String` до тех пор пока какая-нибудь ссылка указывала на неё. Objective-C ведет подсчёт ссылок для решения этой проблемы. В нашем примере было бы ссылки – одна внутренняя переменная ссылающаяся на текст и ещё одна переменная `my_txt`. Переменная `String` могла быть освобождена лишь тогда когда счётчик ссылок станет равен 0. Другими словами, когда больше никто из ссылок не будет существовать.

_Сборщик мусора_ требует дополнительной работы и требует паузы в работе программы для освобождения не нужной памяти. _Подсчёт ссылок_ также требует дополнительной работы и требуется не во всех случаях. _Время жизни_ в Rust предлагает элегантное решение этой проблемы с отсутствием дополнительной работы в среде исполнения.
