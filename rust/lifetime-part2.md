# Время жизни в Rust (Часть 2)

 > [Оригинал статьи](https://mobiarch.wordpress.com/2015/07/08/understanding-lifetime-in-rust-part-ii-3/)

В первой части мы обсуждали причины появления времени жизни в Rust и о том как работает время жизни с функциями. В этой части мы поговорим о том как время жизни помогает хранить ссылку на объект внутри другого объекта.

## Постановка задачи

Мы будем разрабатывать тип `Person`, обозначающего клиента, который должен владеть типом `Car` описывающего автомобиль. Клиент должен будет иметь возможность покупать и продавать автомобили. Два клиента должны иметь возможность обмениваться (или продавать) свои автомобили.

## Определяем типы

Тип `Car` сделаем очень простым:

```rust
struct Car {
    model: String
}
```

Как тип `Person` должен хранить в себе тип `Car`? Можно сделать так:

```rust
struct Person {
    car: Option<Car>
}
```

Так будет просто с точки зрения управления памятью. Но здесь кроются несколько проблем. Автомобиль не является неотъемлемой частью клиента. Покупка и продажа автомобилей будет создавать копии автомобилей, что будет лишь увеличением накладных расходов в программе. Нам хотелось бы чтобы `Person` хранил в `Option` ссылку на `Car`. Вот тут всё становится сложнее.

### Хранение ссылки

В Rust ссылка должна указывать на действующий выделенный участок памяти. Это означает, что объект-контейнер должен жить не меньше чем ссылка, хранящаяся в нём. Rust здесь требует от нас явного указания параметров времени жизни. Добавим в `Person` аннотации для указания времени жизни:

```rust
struct Person<'a> {
    car: Option<&'a Car>
}
```

В **`Person<'a>`** задаём имя времени жизни `a`.

В **`Option<&'a Car>`** указываем, что объект `Car` имеет время жизни `a`.

После этого, компилятор будет знать, что у объекта `Person` будет время жизни `a` или меньше. Это поможет избежать не верной ссылки на `Car`, хранящейся в объекте `Person`.

  > То что мы сделали есть основа здравого смысла. К сожалению, компилятор Rust не позволит опустить аннотации времени жизни в данной ситуации. По крайней мере не сейчас.

### Пишем реализацию

После того как мы описали наш тип, теперь приступим к написанию методов для него:

```rust
impl <'a> Person<'a> {
    fn new() -> Person<'a> {
        Person{
            car: None
        }
    }

    fn buy_car(&mut self, c : &'a Car) {
        self.car = Some(c);
    }

    fn sell_car(&mut self) {
        self.car = None;
    }    
}
```

Здесь все методы которые нам понадобятся, кроме торговли автомобилями между клиентами. Это реализуем чуть позже в этом руководстве.

Как вы можете заметить, аннотации времени жизни очень похожи на [шаблоны](https://doc.rust-lang.org/stable/book/generics.html) (полное имя типа: `Person<'a>`). Именно поэтому мы начинаем реализацию типа с `impl <'a> Person<'a>`, как если бы мы объявили шаблон для типа `Person`. Здесь мы можем указать разные реализации для различных видов времени жизни. Но пока нам рано думать об этом.

### Использование ссылки в объекте

Отлично! Давайте попробуем использовать наш тип:

```rust
fn main() {
    let car = Car{model: "Honda Civic".to_string()};
    let mut bob = Person::new();

    bob.buy_car(&car);
}
```

Этот код будет компилироваться и работать. Но если мы поменяем местами две строки, то код перестанет компилироваться:

```rust
fn main() {
    let mut bob = Person::new();
    let car = Car{model: "Honda Civic".to_string()};

    bob.buy_car(&car); // Ошибка!
}
```

Объекты уничтожаются в обратном порядке их объявления. Это означает, что переменная `car` уничтожится перед `bob`. В итоге `bob` будет хранить в себе не правильную ссылку на `car`, пусть даже на какие-то доли миллисекунды. Rust не позволит на такое сделать.

Система времени жизни не может предсказать когда ссылка будет не нужна. Рассмотрим следующий пример ниже.

```rust
fn main() {
    let ghibli = Car{model: "Maserati Ghibli".to_string()};
    let mut bob = Person::new();

    { 
        // Внутренняя область видимости

        let civic = Car{model: "Honda Civic".to_string()};

        bob.buy_car(&civic); // Ошибка!
        bob.buy_car(&ghibli);
    }    
}
```

Код не будет компилироваться, т.к. время жизни переменной `civic` меньше чем у `bob`. Это странно, т.к. с точки зрения разработчика код безопасен. В конце внутренней области видимости переменной `bob` больше не ссылается на `civic`. Система строго следует нашему объявлению метода `buy_car(&mut self, c : &'a Car)`, где указано что `Car` имеет время жизни `a` и объект `Person` не должен иметь время жизни больше чем у `Car`.

### Реализация торговли между клиентами

Торговля будет подразумевать обмен машинами между экземплярами объектов `Person`. Добавим реализацию метода:

```rust
fn trade_with(&mut self, other : &mut Person<'a>) {
    let tmp = other.car;

    other.car = self.car;
    self.car = tmp;
} 
```

Здесь нет ничего особенного. Можно лишь указать то что время жизни является частью типа данных. Переменная `other` имеет тип данных `&mut Person<'a>`.

Мы сейчас попробуем использовать метод `trade_with()`.

```rust
fn main() {
    let civic = Car{model: "Honda Civic".to_string()};
    let ghibli = Car{model: "Maserati Ghibli".to_string()};

    let mut bob = Person::new();
    let mut alice = Person::new();

    bob.buy_car(&civic);
    alice.buy_car(&ghibli);

    bob.trade_with(&mut alice);
}
```

Объекты `Car` до сих требуется создавать перед созданием объектов `Person`. Но не имеет значение очерёдность объявлений `bob` и `alice`.

### Применение правил заимствования

Когда объект хранит ссылку на другой объект, то он заимствует ссылку и применяются стандартные правила заимствования. 

Вы можете иметь множество неизменяемых заимствований до тех пор пока нет изменяемого заимствования.

```rust
let ghibli = Car{model: "Maserati Ghibli".to_string()};
let mut bob = Person::new();

bob.buy_car(&ghibli); // bob заимствует неизменяемую ссылку на ghibli

let p1 = &ghibli; // Можем ещё заимствовать неизменяемую ссылку на ghibli
let p2 = &ghibli;
```

Изменяемое заимствование эксклюзивно и разрешается лишь тогда, когда нет другого вида заимствования.

```rust
let mut ghibli = Car{model: "Maserati Ghibli".to_string()};
let mut bob = Person::new();

bob.buy_car(&ghibli); // bob заимствует изменяемую ссылку на ghibli

let p1 = &mut ghibli; // Нельзя это сделать. Ошибка!
```

Вы не можете _переместить_ объект пока кто-то владеет его ссылкой. Потому что позаимствованная ссылка будет указывать на неправильную область памяти.

```rust
let mut ghibli = Car{model: "Maserati Ghibli".to_string()};
let mut bob = Person::new();

bob.buy_car(&ghibli); // bob заимствует ссылку на ghibli

let g = ghibli; // Нельзя переместить. Ошибка.
```

Это, однако, будет несколько неожиданно.

```rust
let civic = Car{model: "Honda Civic".to_string()};
let mut ghibli = Car{model: "Maserati Ghibli".to_string()};
let mut bob = Person::new();

bob.buy_car(&ghibli);
bob.buy_car(&civic);

let p1 = &mut ghibli; // Неожиданно. Ошибка!
```

С точки зрения разработчика код является безопасным. `bob` больше не нуждается в заимствовании ссылки на `ghibli` в то время как мы пытаемся позаимствовать изменяемую ссылку на `ghibli`. Но компилятор не может догадаться об этом.

## Не всё так хорошо

Отличные новости. Мы имеем представление о модели хранения указателей в объектах. Плохая новость в том, что эта модель не всегда работает. Рассмотрим функцию. Это не будет компилироваться:

```rust
fn shop_for_car(p: &mut Person) {
    let car = Car{model: "Mercedes GLK350".to_string()};

    p.buy_car(&car); // Ошибка!
}
```

Проблема в том, что у объекта `car` время жизни меньше чем у `Person`. Это случилось из-за того что `car` живёт только лишь локально в области видимости этой функции. Для решения этой проблемы требуется выделить память в куче и разместить там объект `car`, что можно сделать в Rust с помощью [`Box<T>`](https://doc.rust-lang.org/stable/std/boxed/). Но об этом мы поговорим в третьей части серии статей о времени жизни в Rust.
