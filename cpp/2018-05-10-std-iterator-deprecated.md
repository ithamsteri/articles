---
title: "std::iterator устарел: почему, зачем и что использовать взамен?"
date: 2018-05-10T00:15:00+03:00
tags: ["cpp", "cpp17", "stl"]
slug: "std-iterator-deprecated"
---

Это пeревод статьи
[Джонатана Боккара](https://www.fluentcpp.com/2018/05/08/std-iterator-deprecated/).

В STL C++17 устарело несколько компонентов, которые были с самого начала C++ и 
`std::iterator` один из них.

<!--more-->

Скорее всего в вашем проекте не используется C++17 на данный момент. Но рано 
или поздно вам придётся его использовать. Лучше уже сегодня подготовиться и 
перестать использовать устаревшие компоненты STL.

Посмотрим как использовался `std::iterator`, почему он устарел и что 
использовать вместо него.

# Особенности итератора

`std::iterator` использовался для указания **особенностей итератора** .

Что это значит?

Обобщённый код, который использует интенсивно итераторы, такой как алгоритмы 
стандартной библиотеки, нуждается в информации о них. Например, ему нужен тип 
объекта, на который ссылается итератор. Чтобы получить эту информацию, 
стандартная библиотека требует, чтобы итератор объявил тип с именем 
`value_type`.

Для иллюстрации рассмотрим алгоритм `std::reduce`. Одна из его перегрузок 
принимает два итератора и возвращает сумму объектов, которые находятся между 
этими двумя итераторами:

```cpp
std::vector<int> numbers = {1, 2, 3, 4, 5};

std::cout << std::reduce(begin(numbers). end(numbers)) << '\n';
```

Этот код выведет в консоль сумму всех элементов вектора `number`, которое равно 
`15`.

Но что если коллекция чисел будет пустой?

```cpp
std::vector<int> numbers = {};

std::cout << std::reduce(begin(numbers), end(numbers)) << '\n';
```

Что должен вывести этот код? В описании для функции `std::reduce` говорится, 
что она вернёт объект, который будет инициализирован значением по умолчанию, 
используя пустые фигурные скобки `{}`. В нашем случае это будет `int{}`, 
который имеет значение `0`.

Откуда `std::reduce` знает, что вектор `number` содержит элементы типа `int`? 
Функция не работает с вектором напрямую, т.к. она взаимодействует с его 
итераторами, полученными из функций `begin()` и `end()`.

Вот почему итераторы должны объявлять тип `value_type`, который в данном случае 
является типом элементов вектора `int`.

Также может потребоваться получить информацию о возможностях итератора: может 
это итератор ввода, который поддерживает `++`, но не должен быть прочитан 
дважды? Или может это однонаправленный итератор, который можно прочитать 
несколько раз? Или это двунаправленный итератор, который поддерживает `--`? Или 
это итератор произвольного доступа, где можно перемещаться с помощью операторов 
`+=`, `+`, `-=` и `-`? Или это итератор вывода?

Эта информация полезна для некоторых алгоритмов, которые будут эффективнее в 
зависимости от возможностей итератора. Такой алгоритм обычно имеет несколько 
реализаций и выбирается в зависимости от категории итератора.

STL требует, чтобы итераторы предоставляли тип `iterator_category`, который 
описывает категорию итератора. Существуют следующие категории:

* `std::input_iterator_tag`,
* `std::forward_iterator_tag`,
* `std::bidirectional_iterator_tag`,
* `std::random_access_iterator_tag`,
* `std::output_iterator_tag`.

Также STL требует ещё три типа у итератора, кроме `value_type` и 
`iterator_category`:

* `difference_type`: тип, который является результатом разницы двух итераторов;
* `pointer`: тип указателя на элемент, на который ссылается итератор;
* `reference`: тип ссылки на элемент, на который ссылается итератор.

Итого нужно итератору определить пять типов.

Все итераторы в стандартной библиотеке соответствуют этому (статическому) 
интерфейсу. Если вам нужно реализоваться свой собственный итератор, **вам также 
необходимо определить эти типы**.

## std::iterator_traits

Если вы хотите получить доступ к этим пяти типам у итератора, то можно 
подумать, что все итераторы определяют все эти пять типов. Например, можно
получить тип элемента: `Iterator::value_type`.

Это почти всегда так, кроме одного исключения - когда итератор является 
указателем. Некоторые STL реализации используют указатели как итераторы вектора 
(арифметика указателей хорошо подходит для операций с итератором). Также может 
использоваться указатель в случае для итерирования по массиву в стиле языка Си.

В случае с указателем мы не можем получить тип элемента `int*::value_type`, 
т.к. указатель не имеет вложенных типов!

Чтобы решить эту проблему, предлагается **не вызывать напрямую** `::value_type` 
или `::iterator_category`, а использовать шаблон `std::iterator_traits`, 
который предоставляет все пять типов.

Если тип `Iterator` из шаблона `std::iterator_traits<Iterator>` не является 
указателем, то типы `std::iterator_traits` просто берутся у типа `Iterator`. 
Например:

```cpp
std::iterator_traits<Iterator>::value_type
```

будет означать что и:

```cpp
Iterator::value_type
```

Но если тип шаблона окажется указателем, скажем `T*`, то тогда 
`std::iterator_traits<T*>::value_type` вернёт тип `T` и тип 
`std::iterator_traits<T*>::iterator_category` всегда будет равен 
`std::random_access_iterator_tag`.

# std::iterator

Шаблон `std::iterator` помогает объявить типы итератора, который принимает 5 
шаблонных параметров:

```cpp
template<
    typename Category,
    typename T,
    typename Distance = std::ptrdiff_t,
    typename Pointer = T*,
    typename Reference = T&
> struct iterator;
```

Эти пять параметров нам уже знакомы, не так ли? Эти типы шаблона соотвествуют 
пяти типам, которые требует STL.

Задача шаблона `std::iterator` состоит в том, чтобы объявить эти типы. Вот 
возможная реализация `std::iterator`:

```cpp
template<
    typename Category,
    typename T,
    typename Distance = std::ptrdiff_t,
    typename Pointer = T*,
    typename Reference = T&
> struct iterator
{
    using iterator_category = Category;
    using value_type = T;
    using difference_type = Distance;
    using pointer = Pointer;
    using reference = Reference;
};
```

Чтобы использовать шаблон `std::iterator` для определения пяти типов - нужно 
наследоваться от него и передать как минимум два параметра, т.к. остальные три 
параметра имеют значения по умолчанию:

```cpp
class MyIterator : public std::iterator<std::random_access_iterator, int>
{
  // ...
};
```

 Теперь класс `MyIterator` имеет пять типов, которые требует STL от итераторов.

# Зачем отказываться от использования std::iterator?

Этот шаблон кажется очень полезным, так зачем от него отказываться?

Важно отметить, что устарел только шаблон `std::iterator`. Это не касается пяти 
типов, которые должен определять итератор для предоставления информации о себе.

Теперь нужно отказаться от наследования от `std::iterator` для определения 
типов. Вот и всё!

Так что же не так с `std::iterator`?

Давайте представим наследование от `std::iterator` с указанием пяти типов в 
качестве параметров:

```cpp
class MyIterator : public std::iterator<std::forward_iterator_tag, int, int, 
int*, int&>
{
	// ...
}
```

В этом коде не ясно, какой тип передаётся каждому из типов итератора.

Более явный способ указать типы - написать декларации `using` (или `typedefs`, 
если вы используете стандарт до C++11) непосредственно внутри итератора:

```cpp
class MyIterator
{
	public:
		using iterator_category = std::forward_iterator_tag;
		using value_type = int;
		using difference_type = int;
		using pointer = int*;
		using reference = int&;
  
		// ...
};
```

Поэтому лучше определять типы внутри итератора явно, чем с помощью 
`std::iterator`. Такой код легче читать и меньше шанс сделать ошибку.

Также
[документ P0174](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0174r2.html#2.1)
 
предлагает ещё причину для прекращения использования `std::iterator`. 
Отсутствие ясности кода ещё заметнее при определении итератора вывода:

```cpp
class MyOutputIterator : public std::iterator<std::output_iterator_tag, void, 
void, void, void>
{
		// ...
};
```

Для того, чтобы убедить комитет стандартизации C++ отказаться от 
`std::iterator` достаточно было причины отсутствия ясности кода, но есть ещё
одна причина данного подхода при наследовании: вы не можете обращаться напрямую
к псевдонимам типов базового класса. Например, вы не можете получить тип
`value_type`:

```cpp
class MyIterator : public std::iterator<std::forward_iterator_tag, int>
{
		value_type data;	// тип value_type неизвестен
 
    // ...
};
```

Также отмечено в [LWG2438](https://cplusplus.github.io/LWG/issue2438), что 
необходимо убрать `std::iterator` из STL, т.к. вводит пользователей в 
заблуждение, что их собственные итераторы должны использовать наследование 
`std::iterator`, а также функции могут получать `std::iterator` в качестве 
аргумента.

# Минусы ручного определения типов

## Нет определения типов по умолчанию

Мы уже упоминали, что `std::iterator` имеет  три шаблонный параметра по 
умолчанию:

```cpp
template< 
    typename Category,
    typename T,
    typename Distance = std::ptrdiff_t,
    typename Pointer = T*,
    typename Reference = T& 
> struct iterator;
```

Поэтому было достаточно указать как минимум два обязательных типа:

```cpp
class MyIterator : public std::iterator<std::forward_iterator_tag, int>
{
		// ...
};
```

Теперь нужно полностью определить все пять типов внутри вашего собственного 
итератора.

## Случай с итератором вывода

Итератор вывода, такой как `std::back_inserter` (если быть точнее, то итератор 
сгенерированный этой функцией), также должны определять типы: 
`iterator_category` является `std::output_iterator_tag`, а остальные типы как 
`void`.

Последние четыре типа определяются как `void`, т.к. они не используются при 
работе с итераторами вывода. С `std::iterator` мы бы использовали для 
определения итератора вывода следующим образом:

```cpp
class MyOutputIterator : public std::iterator<std::output_iterator_tag, void, 
void, void, void>
{
		// ...
};
```

Здесь всё равно пришлось указывать все пять типов.

Когда я узнал о том что `std::iterator` сделали устаревшим в C++17, то подумал, 
что причина в определении итераторов вывода.

Можно подумать, что для итератора вывода достаточно объявить только тип 
`iterator_category`, а остальные всё равно не используются:

```cpp
class MyOutputIterator
{
	public:
		using iterator_category = std::output_iterator_tag;
		// остальные типы не определяем
  
  	// ...реализация итератора...
};
```

Но этот код не выполняет требования STL по определению пяти типов для
итератора, но может работать на некоторых платформах. Такой код не переносим на
другие платформы. Правильно будет объявить все пять типов итератора:

```cpp
class MyOutputIterator
{
	public:
    using iterator_category = std::output_iterator_tag;
    using value_type = void; // приходится определять все типы :(
    using difference_type = void;
    using pointer = void;
    using reference = void;
  
    // ...реализация итератора...
};
```

Если вам интересно почему некоторые платформы позволяют использовать один тип 
`iterator_category`, а другие - нет, то мы рассмотрим реализацию 
`std::iterator_traits` в STL поставляемой с компиляторами GCC и Clang. Если вам 
это не важно, то можете переходить к разделу заключение. Главное помнить, чтобы 
код был переносимым нужно определять все пять типов у итератора.

Итак, почему некоторые платформы заставляют вас писать все 5 типов, даже если 
вы их не используете?

### libstdc++, используемый GCC

Если вы посмотрите в исходный код 
[libstdc++](https://github.com/gcc-mirror/gcc/blob/7b35a939b8cb869efb830701cef4fa1dc5ff4020/libstdc%2B%2B-v3/include/bits/stl_iterator_base_types.h),
используемый GCC, то вы увидите, что `std::iterator_traits` реализован
следующим образом:

```cpp
template<typename _Iterator>
struct iterator_traits
{
    typedef typename _Iterator::iterator_category iterator_category;
    typedef typename _Iterator::value_type        value_type;
    typedef typename _Iterator::difference_type   difference_type;
    typedef typename _Iterator::pointer           pointer;
    typedef typename _Iterator::reference         reference;
};
```

Если вы попытаетесь получить к одному любому типу из пяти, то тогда шаблон 
инстанцируется и определит типы, основываясь на типах `_Iterator`. Если хотя бы 
один тип не существует, то это приведёт к ошибке компиляции. 

### libc++, используемый Clang

И если вы посмотрите код в 
[libc++](https://github.com/llvm-mirror/libcxx/blob/master/include/iterator), 
используемый Clang, то вы заметите, что `std::iterator_traits` здесь реализован 
по-другому чем в libstdc++:

```cpp
template <class _Iter>
struct _LIBCPP_TEMPLATE_VIS iterator_traits
		: __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};
```

Определение типов в этом коде нет непосредственно в `std::iterator_traits`. Эти 
определения типов находятся в базовом классе. Это очень важно, т.к. если вы 
попытаетесь использовать любой один тип в своём коде (например, 
`iterator_category`), то ваш код скомпилируется, даже если отсутствует любой 
тип, даже `value_type`.

Честно говоря, я не знаю, какое языковое правило позволяет это сделать в этом 
случае. Если вы знаете, как это работает, то пожалуйста поделитесь знанием в 
комментариях.

GCC и Clang очень популярны при разработке и одна из платформ не поддерживает 
создание итератора без указания всех пяти типов. Все эти типы лучше определять, 
чтобы не было проблем с переносимостью кода.

# Заключение

`std::iterator` устарел и мы должны прекратить его использовать. В следующих 
стандартах может быть он удалён из STL как это случилось с `std::auto_ptr`.

Альтернативой использования `std::iterator` в C++03 является простое объявление 
пяти псевдонимов типов внутри ваших итераторов. Даже если ваш код не 
используется все пять псевдонимов - всё равно определите их, чтобы итератор 
соответствовал требованиям STL.
